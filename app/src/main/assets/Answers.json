{
  "Answers": [
    {
      "ID": 1,
      "OptA": "A computer programming model that organizes software design around data, or objects, rather than functions and logic",
      "OptB": "A style of programming characterized by the identification of classes of objects closely linked with the methods (functions) with which they are associated.",
      "OptC": "None of the above",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 2,
      "OptA": "Abstraction and Polymorphism",
      "OptB": "Encapsulation",
      "OptC": "Inheritance",
      "OptD": "All of the above.",
      "correctOpt": "All of the above"
    },
    {
      "ID": 3,
      "OptA": "User-defined data types that act as the blueprint for individual objects, attributes and methods",
      "OptB": "A template definition of the methods and variables in a particular kind of object",
      "OptC": "None of the above.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 4,
      "OptA": "Instances of a class created with specifically defined data",
      "OptB": "An abstract data type with the addition of polymorphism and inheritance",
      "OptC": "None of the above.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 5,
      "OptA": "Data abstraction means hiding the details about the data.",
      "OptB": "Control abstraction means hiding the implementation details.",
      "OptC": "One of the pillars of OOP.",
      "OptD": "All of the above.",
      "correctOpt": "All of the above"
    },
    {
      "ID": 6,
      "OptA": "The process of enclosing one or more items within a physical or logical package.",
      "OptB": "the bundling of data, along with the methods that operate on that data, into a single unit.",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 7,
      "OptA": "Inheritance allows us to define a class in terms of another class.",
      "OptB": "mechanism where you can to derive a class from another class for a hierarchy of classes that share a set of attributes and methods.",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 8,
      "OptA": "One interface, multiple functions.",
      "OptB": "the provision of a single interface to entities of different types, or the use of a single symbol to represent multiple different types",
      "OptC": "Neither a or b",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 9,
      "OptA": "Structured programming allows developing a program using a set of modules or functions.",
      "OptB": "The object oriented programming allows constructing a program using a set of objects and their interactions",
      "OptC": "Neither a or b",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 10,
      "OptA": "Structures are value types",
      "OptB": "Classes are reference types",
      "OptC": "Neither a or b",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 11,
      "OptA": "Shows the relationship within the module",
      "OptB": "The degree to which the elements inside a module belong together",
      "OptC": "How a single class is designed",
      "OptD": "All of the above.",
      "correctOpt": "All of the above"
    },
    {
      "ID": 12,
      "OptA": "Shows the relationship between modules",
      "OptB": "How classes interact with each other",
      "OptC": "the degree of direct knowledge that one element has of another",
      "OptD": "All of the above.",
      "correctOpt": "All of the above"
    },
    {
      "ID": 13,
      "OptA": "a class from which other classes inherit code",
      "OptB": " the class from which many subclasses can be created",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 14,
      "OptA": "classes that inherit one or more language entities from another class.",
      "OptB": "class that inherits state and behavior from all of its ancestors.",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 15,
      "OptA": "Static Polymorphism is where the decision to resolve which method to accomplish, is determined during the compile time. ",
      "OptB": "Dynamic Polymorphism: is where the decision to choose which method to execute, is set during the run-time",
      "OptC": "Neither a nor b",
      "OptD": "Both a and b",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 16,
      "OptA": "Public",
      "OptB": "Protected",
      "OptC": "Private",
      "OptD": "All of the above.",
      "correctOpt": "All of the above"
    },
    {
      "ID": 17,
      "OptA": "A blueprint that can be used to implement a class",
      "OptB": "A programming structure/syntax that allows the computer to enforce certain properties on an object",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 18,
      "OptA": "A special method of a class or structure in object-oriented programming that initializes a newly created object of that type",
      "OptB": "A special type of subroutine called to create an object",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 19,
      "OptA": "A member function that is invoked automatically when the object goes out of scope or is explicitly destroyed by a call to delete",
      "OptB": "a method which is invoked mechanically just before the memory of the object is released",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 20,
      "OptA": "A mechanism for processing errors and exceptional situations",
      "OptB": "the process of responding to unwanted or unexpected events when a computer program runs",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 21,
      "OptA": "A class defines the structure and behaviors of all entities of a given type",
      "OptB": "An object is one particular instance of that type of entity",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 22,
      "OptA": "Overriding occurs when the method signature is the same in the superclass and the child class",
      "OptB": "Overloading occurs when two or more methods in the same class have the same name but different parameters",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 23,
      "OptA": "Allow you to create blueprints for concrete classes.",
      "OptB": "A restricted class that cannot be used to create objects",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 24,
      "OptA": "An interface cannot have state",
      "OptB": "Abstract class can have state with instance variables",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 25,
      "OptA": "An association is known as composition when one object owns another",
      "OptB": "Association is known as aggregation when one object uses another object",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 26,
      "OptA": "A class should have one and only one reason to change, meaning that a class should have only one job.",
      "OptB": "First principle of SOLID",
      "OptC": "Neither a or b",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 27,
      "OptA": "Objects or entities should be open for extension but closed for modification.",
      "OptB": "Second principle of SOLID",
      "OptC": "Neither a or b",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 28,
      "OptA": "every subclass or derived class should be substitutable for its base or parent class.",
      "OptB": "Third principle of SOLID",
      "OptC": "Neither a or b",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 29,
      "OptA": "A client should never be forced to implement an interface that it does not use, or clients should not be forced to depend on methods they do not use.",
      "OptB": "Fourth principle of SOLID",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    },
    {
      "ID": 30,
      "OptA": "Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level module, but they should depend on abstractions.",
      "OptB": "Fifth principle of SOLID",
      "OptC": "Neither a or b.",
      "OptD": "Both a and b.",
      "correctOpt": "Both a and b."
    }
  ]
}
